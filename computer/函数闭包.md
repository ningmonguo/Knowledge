# 闭包

### 1，概念

> 闭包是函数式编程中一个重要的概念。要了解闭包，首先要先了解几个数学中拓扑学的集合概念，闭集，开集，闭包。

**闭集与开集**

一般的，有a和b是已知实数，我们把集合[a,b]，这样的集合称为闭集，把(a,b)这样的集合称为开集。

由以上结论，若设集合A = (a,b) ,b = {a,b}.这里A是一个范围，B是由两个数构成的集合。那么可以得到

A U B = [a, b] 是一个闭集。

通俗的讲，开集 + 边界 = 闭集

**闭包**

在上述基础上，我们把A U B称为A的闭包，可见闭包是一个闭集。由此，我们可以知道闭包是包括开集及其边界的一个集合。

### 2，函数编程中的闭包

> 函数编程中，我们把在函数内部声明的函数叫做这个函数闭包。

基于闭包概念，可知函数的闭包应该包含函数与及其不包含的边界。这种哲学反映在在了函数的变量上，闭包可以使用函数中的变量，而且是函数中的最终变量。说明闭包包含了函数里面所有的运算，所以叫闭包嘛。

接下来看golang中闭包的长相

```go
func main() {
	A()()
}

func A() func() {
	return func() {
		fmt.Print("这是一个闭包")
	}
}
```

从上面看，返回的函数就是函数A的闭包。

接下来需要与闭包概念统一，即闭包应包含函数A中的所有操作。

```go
func main() {
	A()()
}

func A() func() {
	b := 1
	a := func() {
		fmt.Print("闭包中的变量", b)
	}
	b = 3
	return a 
}
// 闭包中的变量3
```

显然可以理解成闭包需要包含函数A中的所有操作，所以这个b应该是函数执行完毕后的值，所以b需要是3

接下来再看一段代码：

```go
func main() {
	A()()
}

func A() func()func() {
	b := 1
	a := func() func(){
        b = 2
		return func() {
			fmt.Println("这是一个闭包", b)
		}
        b = 5
	}
	b = 3
	return a
}
//这是一个闭包5
```

闭包，对于A来说，func()func()才是A的闭包，我们暂时不把闭包的闭包也是他的闭包拿出来讲。如上的程序，func()func()的闭包是func(),func()中的这个b是从func()()中拿的，那func()func()的变量就要去A中拿，所以出现了闭包中的变量就近原则。

通过上述基础，我们知道了为什么闭包要这样设计，那么这样的设计是怎么做的呢？这个再网上有很多资料，包括作用域链，闭包与自定义变量的存储再堆上，这些都是为了实现闭包的设计。